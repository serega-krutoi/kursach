Идея простая:

Есть учебный план (дисциплины, группы, преподы, аудитории, даты/слоты), и тебе нужно автоматически составить расписание экзаменов так, чтобы:
- у одной группы не было двух экзаменов одновременно;
- у препода не было двух экзаменов одновременно;
- аудитория не была занята двумя экзаменами;
- можно ещё добавить ограничения (макс. 1 экзамен в день для группы, выходные дни не трогаем и т.п.).




1. Использование графа и раскраски (модель конфликтов экзаменов)

Проанализировать предметную область и выделить условия конфликтов экзаменов (общая группа, общий преподаватель, ограниченные аудитории и т.д.).
Спроектировать графовую модель:
- вершина графа — один экзамен;
- ребро между вершинами — наличие конфликта (невозможность одновременного проведения).
Реализовать структуру данных для хранения графа конфликтов (список смежности или матрица смежности).
Разработать алгоритм построения графа по исходным данным учебного плана.
Реализовать жадный алгоритм раскраски графа:
- определить порядок обхода вершин (например, по убыванию степени);
- назначать минимальный доступный «цвет» (временной слот), не конфликтующий с уже окрашенными соседями.
Связать «цвета» графа с реальными временными слотами (дата/время проведения экзаменов).
Провести тестирование работы алгоритма на нескольких наборов входных данных (малый/средний/большой сценарий).
Описать в пояснительной записке графовую модель и алгоритм раскраски, указав оценку сложности и ограничения подхода.

5. Отдельный модуль проверки корректности расписания

Сформулировать критерии корректности расписания:
- отсутствие пересечений экзаменов по группам;
- отсутствие пересечений по преподавателям;
- отсутствие пересечений по аудиториям;
- соблюдение допустимых временных интервалов.

Спроектировать отдельный модуль/класс проверки расписания (валидатор), не зависящий от конкретного алгоритма генерации.
Реализовать функции проверки по каждому типу ограничений (группы, преподаватели, аудитории, временные окна).
Реализовать функцию суммарной проверки расписания, возвращающую список найденных конфликтов или подтверждение корректности.
Добавить подсчёт статистики по расписанию (количество экзаменов в день на группу, нагрузка преподавателей и т.п.).
Встроить вызов модуля проверки в общий процесс генерации расписания.
Подготовить набор тестовых сценариев с заведомо корректными и некорректными расписаниями для проверки работы модуля.
Описать модуль проверки в пояснительной записке, выделив его роль для повышения надежности и сопровождаемости системы.

6. Эвристика по «сложности» экзаменов (сложные в конце сессии)

Ввести критерии «сложности» экзамена (например, тип дисциплины, объём материала, статистика успеваемости, экспертная оценка).
Определить шкалу приоритетов (коэффициентов сложности) для дисциплин.
Реализовать хранение информации о сложности экзамена в структуре данных (поле в сущности «Экзамен» или «Дисциплина»).
Разработать эвристику упорядочивания экзаменов таким образом, чтобы более сложные экзамены стремились к размещению ближе к концу экзаменационного периода.
Встроить сортировку экзаменов по «сложности» и/или по «желательной дате» в алгоритм генерации расписания.
Предусмотреть возможные конфликты между эвристикой сложности и жёсткими ограничениями (недоступность аудиторий, занятость преподавателей) и описать, как система их разрешает.
Выполнить сравнительный эксперимент:
- генерация расписания без учёта сложности;
- генерация с учетом эвристики сложности.
Описать в пояснительной записке используемую эвристику и её влияние на результат (примеры распределения сложных экзаменов по датам).

7. Визуализация расписания как приложения/веб-интерфейса

Определить требования к пользовательскому интерфейсу:
- какие сущности нужно отображать (группы, преподаватели, аудитории);
- какие режимы просмотра нужны (по группе, по дате, по преподавателю).
Спроектировать структуру клиентской части (настольное приложение или веб-приложение) для отображения сгенерированного расписания.
Определить формат обмена данными между генератором расписания и интерфейсом (JSON, REST-API и т.д.).
Реализовать компонент/страницу отображения расписания в табличном виде (аналог сетки «дата × время × аудитория/группа»).
Реализовать базовые удобства:
- фильтрация по группе/преподавателю;
- навигация по датам;
- подсветка конфликтов или проблемных мест (если они обнаружены).
Реализовать загрузку данных расписания из backend-части (либо из файла, либо через HTTP-запрос).
Провести тестирование интерфейса на примерах разных расписаний и сценариев использования.
Описать в пояснительной записке архитектуру приложения/сайта и его роль в наглядном представлении результатов работы алгоритмов.

8. Docker + REST API для генерации расписания

Спроектировать серверную часть приложения (backend), предоставляющую REST-интерфейс для генерации расписания.
Определить основные эндпоинты API, например:
- POST /api/schedule/generate — приём входных данных и запуск алгоритма;
- GET /api/schedule/{id} — получение ранее сгенерированного расписания.
Реализовать обработку запросов:
- парсинг входных данных (экзамены, группы, преподаватели, аудитории, слоты);
- вызов модуля генерации расписания;
- возврат результата в удобном формате (JSON).
Подготовить конфигурационные файлы для сборки Docker-образа (Dockerfile).
Настроить сборку и запуск приложения в контейнере (с указанием портов и необходимых зависимостей).
Проверить работу REST-сервиса внутри Docker-контейнера с помощью тестовых запросов (например, curl или Postman).
Описать процесс развертывания системы с использованием Docker (инструкции по запуску контейнера).
Включить в пояснительную записку раздел о контейнеризации и преимуществах использования Docker для развёртывания и тестирования приложения.

9. Выбор алгоритма через аргументы командной строки

Определить перечень поддерживаемых алгоритмов генерации расписания (например: greedy, graph, multithread, heuristic).
Спроектировать механизм конфигурации приложения через аргументы командной строки или параметры конфигурационного файла.
Реализовать разбор аргументов командной строки (помощь/справка, выбор алгоритма, режим отладки и т.д.).
Реализовать фабрику/диспетчер, который по выбранному имени алгоритма вызывает соответствующую реализацию генерации расписания.
Обеспечить единый формат входных и выходных данных для всех алгоритмов, чтобы можно было сравнивать их результаты.
Реализовать вывод информации о выбранном алгоритме и ключевых параметрах при запуске программы.
Подготовить примеры запуска программы с различными алгоритмами и параметрами.
Описать в пояснительной записке механизм выбора алгоритма и его значение для расширяемости и экспериментов с методами генерации.

10. Логирование процесса генерации расписания

Определить, какую информацию необходимо логировать:
- этапы работы алгоритма;
- обнаруженные конфликты;
- выбранные слоты и аудитории;
- ошибки и исключительные ситуации.
Выбрать формат логирования (текстовые файлы, уровни логов: INFO, DEBUG, ERROR).
Реализовать модуль логирования и включить его в ключевые части алгоритма генерации и проверки расписания.
Обеспечить конфигурируемость логирования (включение/выключение подробного режима, выбор уровня детализации).
Добавить логирование начала и завершения основных операций (запуск генерации, выбор алгоритма, проверка расписания, формирование ответа API).
Реализовать механизм записи логов в файл с возможностью последующего анализа.
Провести испытания с включенным логированием, проанализировать примеры логов для нескольких сценариев генерации.
Описать в пояснительной записке назначение системы логирования и её роль в отладке и сопровождении программного обеспечения.